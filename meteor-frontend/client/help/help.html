<div class="help">
	<ul class="nav nav-pills centered">
		<li role="presentation"><a href="#presentation">Presentation</a></li>
		<li role="presentation"><a href="#provider">Provider side</a></li>
		<li role="presentation"><a href="#client">Client side</a></li>
		<li role="presentation"><a href="#docker">Some information about Docker</a></li>
	</ul>

	<span class="anchor" id="presentation"></span>
	<div class="section">
		<h1>Presentation</h1>
		<p>The objective of this project is to allow a user group (member) to pool their laptops or desktop in order to calculate big data of few users. To do so, the solution should work with Docker to virtualize user machines and control the use of resources of each machine.</p>
		<br>
		<img src="http://air.imag.fr/images/5/59/Infrastructure_globale.png" style="display: block; margin-left: auto; margin-right: auto">
	</div>
	<span class="anchor" id="provider"></span>
	<div class="section">
		<h1>What is happening on provider side?</h1>
		
		<h4>First step: user creation</h4>
		<p>Since we can only interact with the coordinator instance from the front-end, we need a way to launch new container. It's not possible to do so from a container, and that task need to be done from the host. That's why the first step is to create a new user on provider machine we will use to launch new containers or stop them. The moment it is done, we deploy necessary scripts in this user's home. Those scripts are necessary to launch and stop new containers. It is simpler for us to do so than transferring those files from the coordinator to the host when the connection is established.</p>

		<h4>Second step: images creation</h4>
		<p>Then, the second step consists in building coordinator and monitoring (shinken) images. To do so we use Dockerfile that allow us to build a container containing all we need. The coordinator instance just contains a ssh web-server. That container exposes it's port 22 and will be used as a jump host to connect the front-end/clients to the other instances.</p>

		<h4>Third step: coordinator and monitoring instance deployment</h4>
		<p>Finally, when the images are successfully built, we can run these containers on Docker deamon. We are now able to connect the front-end to the coordinator instance and deploy instances.</p>

		<h4>Resources management</h4>
		
		<p><b>CPU:</b> To restrict CPU usage, we just need to know the hyper-threading coefficient of provider machine, and remember which CPU is already used. There is a Docker option we can use while launching container that allow us to choose which CPU the container will use to run. The example below shows how this works with 4 CPU (and hyper-threading coefficient is 2).
		<br><br>  
		<img src="http://air.imag.fr/images/thumb/3/37/CPUShare.png/800px-CPUShare.png" style="display: block; margin-left: auto; margin-right: auto">
		<br>
		<b>Memory:</b> While launching a container, we set memory soft limit as the value required/reserved by the client. The hard limit is set as the maximum memory made available by the provider In doing so, a container can use more memory that his soft limit. But if several containers are running on the same host, Docker will ensure that each container doesn't consume more memory than his soft limit.
		<br><br>
		<b>Disk:</b> Docker doesn't seem to provide a functionality to restrict disk usage. And yet, it's really important for us to make sure that a client will not use to much space disk of the provider. To do so, we implemented a watchdog that check every 30 seconds the disk usage of each container and stop them if they reach the limit defined by the provider. We also use that watchdog to inspect and save container's information that will be used on the front-end to display container's state and space disk usage. Thanks to that, clients will know if they are about to reach the limit.
		<br><br>
		<b>Bandwidth:</b> Since all the containers run on the same Docker network, we are able to use Wondershaper to set a limit for bandwidth usage. Then, Docker takes care to divide equitably the available bandwidth to each container.</p>

	</div>
	<span class="anchor" id="client"></span>
	<div class="section">
		<h1>What is happening on client side?</h1>
	</div>
	<span class="anchor" id="docker"></span>
	<div class="section">
		<h1>What is Docker?</h1>
		<p>Docker allows you to package an application with all of its dependencies into a standardized unit for software development. 
		Docker containers wrap up a piece of software in a complete filesystem that contains everything it needs to run: code, runtime, system tools, system libraries – anything you can install on a server. This guarantees that it will always run the same, regardless of the environment it is running in.</p>

		<h4>Lightweight:</h4>
		<p>Containers running on a single machine all share the same operating system kernel so they start instantly and make more efficient use of RAM. Images are constructed from layered filesystems so they can share common files, making disk usage and image downloads much more efficient.</p>

		<h4>Open:</h4>
		<p>Docker containers are based on open standards allowing containers to run on all major Linux distributions and Microsoft operating systems with support for every infrastructure.</p>

		<h4>Secure:</h4>
		<p>Containers isolate applications from each other and the underlying infrastructure while providing an added layer of protection for the application.</p>

		<h2>How is this different from virtual machines?</h2>

		<p>Containers have similar resource isolation and allocation benefits as virtual machines but a different architectural approach allows them to be much more portable and efficient.</p>

		<h4>Virtual Machines:</h4>
		<p>Each virtual machine includes the application, the necessary binaries and libraries and an entire guest operating system - all of which may be tens of GBs in size.</p>

		<h4>Containers:</h4>
		<p>Containers include the application and all of its dependencies, but share the kernel with other containers. They run as an isolated process in userspace on the host operating system. They’re also not tied to any specific infrastructure – Docker containers run on any computer, on any infrastructure and in any cloud.</p>

		<h2>How does this help you build better software?</h2>
		<p>When your app is in Docker containers, you don’t have to worry about setting up and maintaining different environments or different tooling for each language. Focus on creating new features, fixing issues and shipping software.</p>

		<h4>Accelerate Developer Onboarding:</h4>
		<p>Stop wasting hours trying to setup developer environments, spin up new instances and make copies of production code to run locally. With Docker, you can easily take copies of your live environment and run on any new endpoint running Docker.</p>

		<h4>Empower Developer Creativity:</h4>
		<p>The isolation capabilities of Docker containers free developers from the worries of using “approved” language stacks and tooling. Developers can use the best language and tools for their application service without worrying about causing conflict issues.</p>

		<h4>Eliminate Environment Inconsistencies:</h4>
		<p>By packaging up the application with its configs and dependencies together and shipping as a container, the application will always work as designed locally, on another machine, in test or production. No more worries about having to install the same configs into a different environment.</p>

		<h2>Easily Share and Collaborate on Applications</h2>

		<p>Docker creates a common framework for developers and sysadmins to work together on distributed applications.</p>

		<h4>Distribute and share content:</h4>
		<p>Store, distribute and manage your Docker images in your Docker Hub with your team. Image updates, changes and history are automatically shared across your organization.</p>

		<h4>Simply share your application with others:</h4>
		<p>Ship one or many containers to others or downstream service teams without worrying about different environment dependencies creating issues with your application. Other teams can easily link to or test against your app without having to learn or worry about how it works.</p>

		<h2>Ship More Software Faster</h2>

		<p>Docker allows you to dynamically change your application like never before from adding new capabilities, scaling out services to quickly changing problem areas.</p>

		<h4>Ship 7X More:</h4>
		<p>Docker users on average ship software 7X more after deploying Docker in their environment. More frequent updates provide more value to your customers faster.</p>

		<h4>Quickly Scale:</h4>
		<p>Docker containers spin up and down in seconds making it easy to scale an application service at any time to satisfy peak customer demand, then just as easily spin down those containers to only use the resources you need when you need it.</p>

		<h4>Easily Remediate Issues:</h4>
		<p>Docker make it easy to identify issues and isolate the problem container, quickly roll back to make the necessary changes then push the updated container into production. The isolation between containers make these changes less disruptive than traditional software models.</p>
	</div>

	<script type="text/javascript">
		// create the back to top button
		$('body').prepend('<a href="#" class="back-to-top" title="Back to top">Back to Top</a>');

		var amountScrolled = 50;

		$(window).scroll(function() {
			if ( $(window).scrollTop() > amountScrolled ) {
				$('a.back-to-top').fadeIn('slow');
			} else {
				$('a.back-to-top').fadeOut('slow');
			}
		});

		$('a.back-to-top, a.simple-back-to-top').click(function() {
			$('html, body').animate({
				scrollTop: 0
			}, 700);
			return false;
		});
	</script>

	<script type="text/javascript">
		$(function() {
		    // Stick the #nav to the top of the window
		    var nav = $('#nav');
		    var navHomeY = nav.offset().top;
		    var isFixed = false;
		    var $w = $(window);
		    $w.scroll(function() {
			var scrollTop = $w.scrollTop();
			var shouldBeFixed = scrollTop > navHomeY;
			if (shouldBeFixed && !isFixed) {
			    nav.css({
				position: 'fixed',
				top: 0,
				left: nav.offset().left,
				width: nav.width()
			    });
			    isFixed = true;
			}
			else if (!shouldBeFixed && isFixed)
			{
			    nav.css({
				position: 'static'
			    });
			    isFixed = false;
			}
		    });
		});
	</script>
	
</div>
